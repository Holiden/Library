# Git

## Содержание:

1. [Конфигурация](#конфигурация)
2. [.gitattributes](#gitattributes)
3. [Основы Git](#основы-git)
4. [Коммит. Автор и коммитер](#коммит-автор-и-коммитер)
5. [Ветки](#ветки)
6. [Создание новой ветки из последних коммитов, передвижение веток](#создание-новой-ветки-из-последних-коммитов,-передвижение-веток)
7. [Просмотр истории и старых версий](#просмотр-истории-и-старых-версий)
8. [Слияние перемоткой](#слияние-перемоткой)
9. [Удаление веток](#удаление-веток)
10. [Полный список команд](#полный-список-команд)

[На главную](https://github.com/Holiden/Library/blob/master/README.md)

## Конфигурация

Настройки хранятся и задаются флагами (git читает настройки сначала local, затем global, затем system):  
`--system` - настройки на уровне системы.  
Файл располагается: Unix: `/etc/gitconfig`, Windows: `C:\Program Files\Git\etc\gitconfig` и `C:\ProgramData\Git\config`.  
`--global` - настройки на уровне пользователя. **Рекомендуется** все настройки задавать с этим флагом.  
Файл располагается: Unix: `~/.gitconfig`, Windows: `C:\Users\<USERNAME>\.gitconfig`.  
`--local` - настройки на уровне проекта (default).  
Файл располагается: `<project>/.git/config`.

* `git config user.name <имя>` - задать имя пользователя.
* `git config user.email <email>` - задать email пользователя.
* `git config --list` - посмотреть параметры конфигурации.
* `git config --list --global` - посмотреть глобальные параметры конфигурации.
* `git config --unset <параметр>` - удалить параметр из конфига.
* `git config --remove-section <секция>` - удалить всю секцию настроек из конфига.
* `git config core.editor '<путь к редактору>' -w` - настроить редактор по умолчанию. `-w` - ожидать закрытие редактора.
* `git config core.autocrlf <значение>` - настройка автоматического переноса строк. **Рекомендуется** задавать в `.gitattributes`. Значения:  
  `.true` - при записи в git строки с CRLF преобразуются в LF. При чтении с git строки с CRLF преобразуются в LF. Используется для кроссплатформенности.  
  `.input` - при записи в git строки с CRLF преобразуются в LF. При чтении с git ничего не преобразуется. Используется для Windows, если основа на Unix.  
  `.false` - при записи в git строки с CRLF не преобразуются. При чтении с git строки с CRLF не преобразуются. Используется если у всех одна ОС - Windows или Unix.
* `git config core.excludeFile <файл>` - игнорировать файл. **Рекомендуется** задавать в `.gitignore`.
* `git config alias.<алиас> <команда>` - задать сокращённую команду.

[К содержанию](#содержание)

## .gitattributes

Для того, чтобы точно сказать git какие файлы являются текстовыми, а какие не являются, используется файл `.gitattibutes`.

Он указывает к каким файлам применены настройки.

|Шаблон   |Атрибут  |
|---------|---------|
|* text   |= auto   |
|* .html  |text     |

У атрибута может быть 4 варианта:

1. `__` - отсутствие;
2. `text` - явное задание. Означает, что такие файлы всегда текстовые. Для таких файлов включается нормализация при записи в git CRLF -> LF.
3. `text = auto` - указано со значением. Означает, что git сам должен определить текстовый это файл или бинарный. По умолчанию текстовость файлов определяется по содержимому, и если файл текстовый, то при его записи в git включается нормализация CRLF -> LF.
4. `-text` - снято. Снятый атрибут это не тоже самое, что не указанный. Означает, что файл бинарный (его не трогать). Отключает нормализацию текста. Обычно ставят `binary`. Это псевдоним `-text` (его не трогать) `-merge -diff` (отключают текстовое слияние и сравнение для таких файлов).

`text` определяет, что делать с файлом при записи в git. Определяет нужно ли преобразовывать переносы строк.  
`text eol=crlf` определяет, что делать с переносами строк при чтении файла с git в рабочую дерикторию. Значение crlf делает переносы строк Windows. Атрибут `eol` автоматически подразумевает текстовые файлы. Его можно писать без `text`.  
`text eol=lf` определяет, что при чтении файла с git переносы строк менять не надо. Но если файлы в git crlf, то преобразования не в lf не будет.

[К содержанию](#содержание)

## Основы Git

* `git init` - создаёт пустой репозиторий.
* `git status` - показывает статус.
* `git add <файл>` - добавить файл в индекс.
* `git commit` - открыть редактор по умолчанию чтобы написть коммит.

Каждому коммиту присваевается хеш. Все операции с файлами этого коммита проводятся через этот хеш.

Файл с игнор-шаблоном только для текущего пользователя проекта находится `<project>/.git/info/exclude`. Этот файл не передаётся через git.

#### Права на файлы

После добавления файла в репозиторий перед именем файла указывается число, например 100644.  
100 - означает тип файла.  
644 - означает права на этот файл.  
В зависимости от операционной системы права могут быть разными (запись, чтение, выполнение). Git проверяет файлы только на исполнение. Если файл исполнимый, то значение будет 755, если не исполнимый - 644.

* `chmod +x <файл>` - сделать файл исполнимым.
* `chmod -x <файл>` - сделать файл не выполнимым.

Для git изменение права на выполнение существенно наравне с изменением в содержимом файла.

Файловая система Windows обычно не поддерживает отдельное право на выполнение файла. В отличии от Unix систем, в Windows, обычно, оно объеденено с правом на чтение. Под Unix эти права различны. Git при создании репозитория проверяет, если файловая система не поддерживает отдельное право на выполнение, то ставит в настройках `git config core.fileMode false`. Она говорит git, что на права файловой системы вообще не смотреть. Файлы сохранённые в Windows всегда будут 644.

Чтобы создаваемый файл в Windows был исполнимым в Unix:

* `git update-index --chmod=+x <файл>` - сделать файл в индекс исполнимым.
* `git add --chmode=+x <файл>` - сделать файл в рабочей директории исполнимым.

[К содержанию](#содержание)

## Коммит. Автор и коммитер

* `git show` - показать текущий коммит.
* `git show <идентификатор, минимум 4 символа>` - покажет коммит.
* `git show --pretty=fuller` - показать полную информацию о коммите.
* `git commit --author='<имя автора>' --date='<дата>'` - установить имя автора и его дату.

Коммит может быть небольшое, но целостное и осмысленное изменение в проект.

Git не работает с пустыми директориями. Он их не видит. Обычно, чтобы этого избежать создают пустой файл с именем `.gitkeep`.

* `git add .` - добавить к индексу все текущие изменения текущей директории.
* `git add -A` - добавить к индексу все ткущие изменения, начиная с корня проекта.
* `git add -p <файл>` - добавить файл в индекс с возможностью выбора частей изменений.
* `git add --force (или -f)` - добавить файл в индекс, даже если он игнорируется.
* `git commit <файл>` - добавить отдельный файл сразу в индекс и в репозиторий. Файлы, которые git не отслеживает будут проигнорированы.
* `git commit -m '<сообщение>'` - позволяет указать сообщение прямо в командной строке без вызова редактора. Одно слово можно указывать без кавычек.
* `git commit --all (или -a)` - добавить файл в репозиторий игнорируя индекс стадию, но всё равно добавить в индекс. Эта команда игнорирует файлы, которые не отслеживаются git.
* `git mv <файл1> <файл2>` - переименовать файл1 в файл2 и добавить информацию об этом в индекс.
* `git reset HEAD <файл>` - удалить файл из индекса.
* `git rm <файл>` - удаление файла. Можно указывать несколько, Удаляет из рабочей директории и из индекса (псевдоним `rm` + `git add`).
* `git rm -f <имя>` - удалить файл игнорируя предупреждения. Удалить файл с изменениями, которые не были сохранены в репозитории. Все несохранённые изменения будут потеряны.
* `git rm -r <директория>` - удаление директории.
* `git rm --cached <файл>` - удаление файла из индекса, но сохранение в рабочей директории. Операция производится только с индексом, вместо рабочей директории.

[К содержанию](#содержание)

## Ветки

**Ветки** - это изолированный поток разработки, в котором можно делать коммиты так, что их не будет видно из других веток.

* `git branch` - просмотр веток.
* `git branch -v` - просмотр веток и информации о коммите на который они указывают.
* `git checkout <имя ветки>` - переключиться на ветку.
* `git branch <имя ветки>` - создать новую ветку.
* `git checkout -b <имя ветки>` - сздать и переключиться на ветку (`git branch` + `git checkout`).

#### Checkout с незакоммиченными изменениями

Если выполненны изменения не закоммичены, то сменить ветку не удастся. Если файл между ветками различается или в одной ветке файл есть, а в другой он был удалён, тогда будет ошибка, а если файл одинаковый, то незакоммиченные изменения сохраняются при смене ветки.

* `git checkout --force (или -f)` - сменить ветку игнорируя предупреждения.
* `git checkout -f HEAD` - перезаписать файлы той же ветки с последнего коммита. Если просто нужно удалить сделанные изменения. Можно даже не указывать HEAD, потому что если ветка не указана, HEAD используется по умолчанию.
* `git stash` - собирает незакоммиченные изменения, удаляет их из файлов и в специальном виде архивирует в git. Если нужно сменить ветку без удаления незакоммиченных изменений.
* `git stash pop` - вернуть изменения в файл. Так как git не привязывает сохранённые изменения ни к какой ветке, то можно сохранить (`git stash`) имненения на одной ветке, а применить (`git stash pop`) в другой.

[К содержанию](#содержание)

#### Создание новой ветки из последних коммитов, передвижение веток

Если ошибочно сделаны коммиты в ветке master, а не в нужной ветке, то необходимо создать новую ветку и передвинуть ветку master на стабильный коммит.

* `git branch <имя ветки> <идентификатор коммита>` - создать ветку на определённом коммите.
* `git branch --force (или -f) <имя ветки> <идентификатор коммита>` - создать ветку на определённом коммите или переместить ветку, если она уже существует.
* `git checkout -B <имя ветки> <идентификатор коммита>` - создать ветку на определённом коммите или переместить ветку, если она уже существует, и переключиться на неё.

[К содержанию](#содержание)

#### Просмотр истории и старых версий

* `git log` - вывести историю коммитов.
* `git log --oneline` - вывести историю коммитов в компактном виде.

По-умолчанию `git log` выводит историю ветки HEAD, т.е. все коммиты.

* `git log <имя ветки>` - вывести историю коммитов определённой ветки.
* `git show` - показать текущий коммит.
* `git show HEAD~` - показать предшевствующий коммит.
* `git show HEAD~~ (или HEAD~2)` - показать предшевствующий коммит, который находится на 2 коммита ниже текущего.
* `git show HEAD~~~ (или HEAD~3)` - показать предшевствующий коммит, который находится на 3 коммита ниже текущего.

Слово `HEAD` можно сокращать используя символ `@`. На Windows потребуются кавычки.

* `git show @~~~ (или @~3)` - показать предшевствующий коммит, который находится на 3 коммита ниже текущего.
* `git show @~:index.html` - показать файл index.html из коммита родителя.
* `git show <имя ветки>:index.html` - показать файл index.html из определённой ветки.
* `git show :index.html` - показать файл index.html из индекса.
* `git show :/<слово или словосочетание в кавычках>` - показать коммит в названии котороо содержится слово или словосочетание.

[К содержанию](#содержание)

#### Слияние перемоткой

* `git merge <имя ветки>` - слить указанную ветку с master.

Эта команда выполняется алгоритмом fast-forward. При нём не изменения, сделанные в ветке добавляются в master, а наоборот, указатель master перемещается так, чтобы указывать на ту же ветку которую нужно слить.

Команда `git merge` перед слиянием записывает старый идентификатор коммита в файл `.git/ORIG_HEAD`. Его можно использовать в качестве ссылки на коммит.

* `git branch -f master ORIG_HEAD` - вернуть master на коммит, который был перед выполнением команды `git merge`.

[К содержанию](#содержание)

#### Удаление веток

* `git branch -d <имя ветки>` - удалить указанную ветку.

Удалить ветку можно только после слияния её с master. Если удалить ветку не слитую, будет ошибка. Потому что коммиты удалённой ветки больше не будут участвовать не в одной из ветвей разработки. Такие коммиты называются недостежимыми. Со временем git удаляет их из своей базы.

* `git branch -D <имя ветки>` - удалить указанную не слитую ветку.

Git удаляет не ветку, а ссылку на ветку. Поэтому удалённую ветку можно восстановить.

* `git branch <имя ветки> <имя идентификатора>` - восстановить указанную не слитую ветку (имя должно быть одинаковое).

[К содержанию](#содержание)

## Полный список команд

* `git <команда> -h` - вывести опции и короткое описание команды.
* `git add <файл>` - добавить файл в индекс.
* `git add .` - добавить к индексу все текущие изменения текущей директории.
* `git add -A` - добавить к индексу все ткущие изменения, начиная с корня проекта.
* `git add -p <файл>` - добавить файл в индекс с возможностью выбора частей изменений.
* `git add --chmode=+x <файл>` - сделать файл в рабочей директории исполнимым.
* `git add --force (или -f)` - добавить файл в индекс, даже если он игнорируется.
* `git branch` - просмотр веток.
* `git branch <имя ветки>` - создать новую ветку.
* `git branch <имя ветки> <идентификатор коммита>` - создать ветку на определённом коммите.
* `git branch --force (или -f) <имя ветки> <идентификатор коммита>` - создать ветку на определённом коммите или переместить ветку, если она уже существует.
* `git branch -f master ORIG_HEAD` - вернуть master на коммит, который был перед выполнением команды `git merge`.
* `git branch -v` - просмотр веток и информации о коммите на который они указывают.
* `git check-ignore -v <файл>` - проверить игнорирование файла.
* `git checkout <имя ветки>` - переключиться на ветку.
* `git checkout <имя ветки или идентификатор коммита> <имя файла или директории>` - вытащить файл из определённого коммита и добавить его в индекс.
* `git checkout -b <имя ветки>` - сздать и переключиться на ветку (`git branch` + `git checkout`).
* `git checkout -B <имя ветки> <идентификатор коммита>` - создать ветку на определённом коммите или переместить ветку, если она уже существует, и переключиться на неё (`git branch -f` + `git checkout`).
* `git checkout -f HEAD` - перезаписать файлы той же ветки с последнего коммита. Если просто нужно удалить сделанные изменения. Можно даже не указывать HEAD, потому что если ветка не указана, HEAD используется по умолчанию.
* `git checkout --force (или -f) <имя ветки>` - сменить ветку игнорируя предупреждения.
* `git checkout <имя файла>` - вернуть файл из индекса.
* `git checkout HEAD <имя файла>` - вернуть файл из репозитория.
* `git commit` - открыть редактор по умолчанию чтобы написть коммит.
* `git commit <файл>` - добавить отдельный файл сразу в индекс и в репозиторий. Файлы, которые git не отслеживает будут проигнорированы.
* `git commit -m '<сообщение>'` - позволяет указать сообщение прямо в командной строке без вызова редактора. Одно слово можно указывать без кавычек.
* `git commit --all (или -a)` - добавить файл в репозиторий игнорируя индекс стадию, но всё равно добавить в индекс. Эта команда игнорирует файлы, которые не отслеживаются git.
* `git commit --author='<имя автора>' --date='<дата>'` - установить имя автора и его дату.
* `git config alias.<алиас> <команда>` - задать сокращённую команду.
* `git config core.autocrlf <значение>` - настройка автоматического переноса строк. **Рекомендуется** задавать в .`gitattributes`. Значения:
  `.true` - при записи в git строки с CRLF преобразуются в LF. При чтении с git строки с CRLF преобразуются в LF. Используется для кроссплатформенности.
  `.input` - при записи в git строки с CRLF преобразуются в LF. При чтении с git ничего не преобразуется. Используется для Windows, если основа на Unix.
  `.false` - при записи в git строки с CRLF не преобразуются. При чтении с git строки с CRLF не преобразуются. Используется если у всех одна ОС - Windows или Unix.
* `git config core.editor '<путь к редактору>' -w` - настроить редактор по умолчанию. `-w` - ожидать закрытие редактора.
* `git config core.excludeFile <файл>` - игнорировать файл. **Рекомендуется** задавать в `.gitignore`.
* `git config core.pager 'less -RFX'` - конфигурация программы-читалки по умолчанию.
* `git config user.name <имя>` - задать имя пользователя.
* `git config user.email <email>` - задать email пользователя.
* `git config --list` - посмотреть параметры конфигурации.
* `git config --list --global` - посмотреть глобальные параметры конфигурации.
* `git config --remove-section <секция>` - удалить всю секцию настроек из конфига.
* `git config --unset <параметр>` - удалить параметр из конфига.
* `git help <команда>` - подробное описание команды.
* `git init` - создаёт пустой репозиторий.
* `git log` - вывести историю коммитов.
* `git log <имя ветки>` - вывести историю коммитов определённой ветки.
* `git log --oneline` - вывести историю коммитов в компактном виде.
* `git merge <имя ветки>` - слить указанную ветку с master.
* `git mv <файл1> <файл2>` - переименовать файл1 в файл2 и добавить информацию об этом в индекс.
* `git reset HEAD <файл>` - удалить файл из индекса.
* `git rm <файл>` - удаление файла. Можно указывать несколько, Удаляет из рабочей директории и из индекса (псевдоним `rm` + `git add`).
* `git rm -f <имя>` - удалить файл игнорируя предупреждения. Удалить файл с изменениями, которые не были сохранены в репозитории. Все несохранённые изменения будут потеряны.
* `git rm -r <директория>` - удаление директории.
* `git rm --cached <файл>` - удаление файла из индекса, но сохранение в рабочей директории. Операция производится только с индексом, вместо рабочей директории.
* `git show` - показать текущий коммит.
* `git show <идентификатор, минимум 4 символа>` - покажет коммит.
* `git show HEAD~` - показать предшевствующий коммит.
* `git show HEAD~~ (или HEAD~2)` - показать предшевствующий коммит, который находится на 2 коммита ниже текущего.
* `git show HEAD~~~ (или HEAD~3)` - показать предшевствующий коммит, который находится на 3 коммита ниже текущего.
* `git show @~~~ (или @~3)` - показать предшевствующий коммит, который находится на 3 коммита ниже текущего.
* `git show @~:index.html` - показать файл index.html из коммита родителя.
* `git show <имя ветки>:index.html` - показать файл index.html из определённой ветки.
* `git show :index.html` - показать файл index.html из индекса.
* `git show :/<слово или словосочетание в кавычках>` - показать коммит в названии котороо содержится слово или словосочетание.
* `git show --pretty=fuller` - показать полную информацию о коммите.
* `git stash` - собирает незакоммиченные изменения, удаляет их из файлов и в специальном виде архивирует в git. Если нужно сменить ветку без удаления незакоммиченных изменений.
* `git stash pop` - вернуть изменения в файл. Так как git не привязывает сохранённые изменения ни к какой ветке, то можно сохранить (`git stash`) имненения на одной ветке, а применить (`git stash pop`) в другой.
* `git status` - показывает статус.
* `git update-index --chmod=+x <файл>` - сделать файл в индекс исполнимым.

[К содержанию](#содержание)
