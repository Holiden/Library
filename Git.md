#### Содержание:
1. [Конфигурация](#конфигурация)
2. [.gitattributes](#gitattributes)
3. [Основы Git](#основы-git)
4. [Коммит. Автор и коммитер](#коммит-автор-и-коммитер)
5. [Полный список команд](#полный-список-команд)
6. [Ветки](#ветки)

## Конфигурация

Настройки хранятся и задаются флагами (git читает настройки сначала local, затем global, затем system):  

`--system` - настройки на уровне системы.  
Файл располагается: Unix: `/etc/gitconfig`, Windows: `C:\Program Files\Git\etc\gitconfig` и `C:\ProgramData\Git\config`.
`--global` - настройки на уровне пользователя. **Рекомендуется** все настройки задавать с этим флагом.  
Файл располагается: Unix: `~/.gitconfig`, Windows: `C:\Users\<USERNAME>\.gitconfig`.  
`--local` - настройки на уровне проекта (default).  
Файл располагается: `<project>/.git/config`.

* `git config user.name <имя>` - задать имя пользователя.
* `git config user.email <email>` - задать email пользователя.
* `git config --list` - посмотреть параметры конфигурации.
* `git config --list --global` - посмотреть глобальные параметры конфигурации.
* `git config --unset <параметр>` - удалить параметр из конфига.
* `git config --remove-section <секция>` - удалить всю секцию настроек из конфига.
* `git config core.editor '<путь к редактору>' -w` - настроить редактор по умолчанию. `-w` - ожидать закрытие редактора.
* `git config core.autocrlf <значение>` - настройка автоматического переноса строк. **Рекомендуется** задавать в .gitattributes. Значения:  
  `.true` - при записи в git строки с CRLF преобразуются в LF. При чтении с git строки с CRLF преобразуются в LF. Используется для кроссплатформенности.  
  `.input` - при записи в git строки с CRLF преобразуются в LF. При чтении с git ничего не преобразуется. Используется для Windows, если основа на Unix.  
  `.false` - при записи в git строки с CRLF не преобразуются. При чтении с git строки с CRLF не преобразуются. Используется если у всех одна ОС - Windows или Unix.
* `git config core.excludeFile <файл>` - игнорировать файл. **Рекомендуется** задавать в .gitignore.
* `git config alias.<алиас> <команда>` - задать сокращённую команду.

[К содержанию](#содержание)

## .gitattributes

Для того, чтобы точно сказать git какие файлы являются текстовыми, а какие не являются, используется файл .gitattibutes.

Он указывает к каким файлам применены настройки.

|Шаблон | Атрибут |
|-------|---------|
|* text |= auto   |
|* .html|text     |

У атрибута может быть 4 варианта:
1. __ - отсутствие;
2. text - явное задание. Означает, что такие файлы всегда текстовые. Для таких файлов включается нормализация при записи в git CRLF -> LF.
3. text = auto - указано со значением. Означает, что git сам должен определить текстовый это файл или бинарный. По умолчанию текстовость файлов определяется по содержимому, и если файл текстовый, то при его записи в git включается нормализация CRLF -> LF.
4. -text - снято. Снятый атрибут это не тоже самое, что не указанный. Означает, что файл бинарный (его не трогать). Отключает нормализацию текста. Обычно ставят binary. Это псевдоним -text (его не трогать) -merge -diff (отключают текстовое слияние и сравнение для таких файлов).

text определяет, что делать с файлом при записи в git. Определяет нужно ли преобразовывать переносы строк.  
text eol=crlf определяет, что делать с переносами строк при чтении файла с git в рабочую дерикторию. Значение crlf делает переносы строк Windows. Атрибут eol автоматически подразумевает текстовые файлы. Его можно писать без text.  
text eol=lf определяет, что при чтении файла с git переносы строк менять не надо. Но если файлы в git crlf, то преобразования не в lf не будет.

[К содержанию](#содержание)

## Основы Git

* `git init` - создаёт пустой репозиторий.
* `git status` - показывает статус.
* `git add <файл>` - добавить файл в индекс.
* `git commit` - открыть редактор по умолчанию чтобы написть коммит.

Каждому коммиту присваевается хеш. Все операции с файлами этого коммита проводятся через этот хеш.

#### Права на файлы

После добавления файла в репозиторий перед именем файла указывается число, например 100644.  
100 - означает тип файла.  
644 - означает права на этот файл.  
В зависимости от операционной системы права могут быть разными (запись, чтение, выполнение). Git проверяет файлы только на исполнение. Если файл исполнимый, то значение будет 755, если не исполнимый - 644.

* `chmod +x <файл>` - сделать файл исполнимым.
* `chmod -x <файл>` - сделать файл не выполнимым.

Для git изменение права на выполнение существенно наравне с изменением в содержимом файла.

Файловая система Windows обычно не поддерживает отдельное право на выполнение файла. В отличии от Unix систем, в Windows, обычно, оно объеденено с правом на чтение. Под Unix эти права различны. Git при создании репозитория проверяет, если файловая система не поддерживает отдельное право на выполнение, то ставит в настройках git config core.fileMode false. Она говорит git, что на права файловой системы вообще не смотреть. Файлы сохранённые в Windows всегда будут 644.

Чтобы создаваемый файл в Windows был исполнимым в Unix:

* `git update-index --chmod=+x <файл>` - сделать файл в индекс исполнимым.
* `git add --chmode=+x <файл>` - сделать файл в рабочей директории исполнимым.

[К содержанию](#содержание)

## Коммит. Автор и коммитер

* `git show` - показать текущий коммит.
* `git show <идентификатор, минимум 4 символа>` - покажет коммит.
* `git show --pretty=fuller` - показать полную информацию о коммите.
* `git commit --author='<имя автора>' --date='<дата>'` - установить имя автора и его дату.

Коммит может быть небольшое, но целостное и осмысленное изменение в проект.

Git не работает с пустыми директориями. Он их не видит. Обычно, чтобы этого избежать создают пустой файл с именем .gitkeep.

* `git add .` - добавить к индексу все текущие изменения текущей директории.
* `git add -A` - добавить к индексу все ткущие изменения, начиная с корня проекта.
* `git add -p <файл>` - добавить файл в индекс с возможностью выбора частей изменений.
* `git add --force (или -f)` - добавить файл в индекс, даже если он игнорируется.
* `git commit <файл>` - добавить отдельный файл сразу в индекс и в репозиторий. Файлы, которые git не отслеживает будут проигнорированы.
* `git commit -m '<сообщение>'` - позволяет указать сообщение прямо в командной строке без вызова редактора. Одно слово можно указывать без кавычек.
* `git commit --all (или -a)` - добавить файл в репозиторий игнорируя индекс стадию, но всё равно добавить в индекс. Эта команда игнорирует файлы, которые не отслеживаются git.
* `git mv <файл1> <файл2>` - переименовать файл1 в файл2 и добавить информацию об этом в индекс.
* `git reset HEAD <файл>` - удалить файл из индекса.
* `git rm <файл>` - удаление файла. Можно указывать несколько, Удаляет из рабочей директории и из индекса (псевдоним rm + git add).
* `git rm -f <имя>` - удалить файл игнорируя предупреждения. Удалить файл с изменениями, которые не были сохранены в репозитории. Все несохранённые изменения будут потеряны.
* `git rm -r <директория>` - удаление директории.
* `git rm --cached <файл>` - удаление файла из индекса, но сохранение в рабочей директории. Операция производится только с индексом, вместо рабочей директории.

[К содержанию](#содержание)

## Ветки

Ветки - это изолированный поток разработки, в котором можно делать коммиты так, что их не будет видно из других веток.

* `git branch` - просмотр веток.
* `git branch -v` - просмотр веток и информации о коммите на который они указывают.
* `git checkout <имя ветки>` - переключиться на ветку.
* `git branch <имя ветки>` - создать новую ветку.
* `git checkout -b <имя ветки>` - сздать и переключиться на ветку (git branch + git checkout).

#### Checkout с незакоммиченными изменениями

Если выполненны изменения не закоммичены, то сменить ветку не удастся. Если файл между ветками различается или в одной ветке файл есть, а в другой он был удалён, тогда будет ошибка, а если файл одинаковый, то незакоммиченные изменения сохраняются при смене ветки.

* `git checkout --force (или -f)` - сменить ветку игнорируя предупреждения.
* `git checkout -f HEAD` - перезаписать файлы той же ветки с последнего коммита. Если просто нужно удалить сделанные изменения. Можно даже не указывать HEAD, потому что если ветка не указана, HEAD используется по умолчанию.
* `git stash` - собирает незакоммиченные изменения, удаляет их из файлов и в специальном виде архивирует в git. Если нужно сменить ветку без удаления незакоммиченных изменений.
* `git stash pop` - вернуть изменения в файл. Так как git не привязывает сохранённые изменения ни к какой ветке, то можно сохранить (git stash) имненения на одной ветке, а применить (git stash pop) в другой.

[К содержанию](#содержание)

## Полный список команд

* `git add <файл>` - добавить файл в индекс.
* `git add .` - добавить к индексу все текущие изменения текущей директории.
* `git add -A` - добавить к индексу все ткущие изменения, начиная с корня проекта.
* `git add -p <файл>` - добавить файл в индекс с возможностью выбора частей изменений.
* `git add --chmode=+x <файл>` - сделать файл в рабочей директории исполнимым.
* `git add --force (или -f)` - добавить файл в индекс, даже если он игнорируется.
* `git branch` - просмотр веток.
* `git branch <имя ветки>` - создать новую ветку.
* `git branch -v` - просмотр веток и информации о коммите на который они указывают.
* `git checkout <имя ветки>` - переключиться на ветку.
* `git checkout -b <имя ветки>` - сздать и переключиться на ветку (git branch + git checkout).
* `git checkout -f HEAD` - перезаписать файлы той же ветки с последнего коммита. Если просто нужно удалить сделанные изменения. Можно даже не указывать HEAD, потому что если ветка не указана, HEAD используется по умолчанию.
* `git checkout --force (или -f)` - сменить ветку игнорируя предупреждения.
* `git commit` - открыть редактор по умолчанию чтобы написть коммит.
* `git commit <файл>` - добавить отдельный файл сразу в индекс и в репозиторий. Файлы, которые git не отслеживает будут проигнорированы.
* `git commit -m '<сообщение>'` - позволяет указать сообщение прямо в командной строке без вызова редактора. Одно слово можно указывать без кавычек.
* `git commit --all (или -a)` - добавить файл в репозиторий игнорируя индекс стадию, но всё равно добавить в индекс. Эта команда игнорирует файлы, которые не отслеживаются git.
* `git commit --author='<имя автора>' --date='<дата>'` - установить имя автора и его дату.
* `git config alias.<алиас> <команда>` - задать сокращённую команду.
* `git config core.autocrlf <значение>` - настройка автоматического переноса строк. **Рекомендуется** задавать в .gitattributes. Значения:
  `.true` - при записи в git строки с CRLF преобразуются в LF. При чтении с git строки с CRLF преобразуются в LF. Используется для кроссплатформенности.
  `.input` - при записи в git строки с CRLF преобразуются в LF. При чтении с git ничего не преобразуется. Используется для Windows, если основа на Unix.
  `.false` - при записи в git строки с CRLF не преобразуются. При чтении с git строки с CRLF не преобразуются. Используется если у всех одна ОС - Windows или Unix.
* `git config core.editor '<путь к редактору>' -w` - настроить редактор по умолчанию. `-w` - ожидать закрытие редактора.
* `git config core.excludeFile <файл>` - игнорировать файл. **Рекомендуется** задавать в .gitignore.
* `git config user.name <имя>` - задать имя пользователя.
* `git config user.email <email>` - задать email пользователя.
* `git config --list` - посмотреть параметры конфигурации.
* `git config --list --global` - посмотреть глобальные параметры конфигурации.
* `git config --remove-section <секция>` - удалить всю секцию настроек из конфига.
* `git config --unset <параметр>` - удалить параметр из конфига.
* `git init` - создаёт пустой репозиторий.
* `git mv <файл1> <файл2>` - переименовать файл1 в файл2 и добавить информацию об этом в индекс.
* `git reset HEAD <файл>` - удалить файл из индекса.
* `git rm <файл>` - удаление файла. Можно указывать несколько, Удаляет из рабочей директории и из индекса (псевдоним rm + git add).
* `git rm -f <имя>` - удалить файл игнорируя предупреждения. Удалить файл с изменениями, которые не были сохранены в репозитории. Все несохранённые изменения будут потеряны.
* `git rm -r <директория>` - удаление директории.
* `git rm --cached <файл>` - удаление файла из индекса, но сохранение в рабочей директории. Операция производится только с индексом, вместо рабочей директории.
* `git show` - показать текущий коммит.
* `git show <идентификатор, минимум 4 символа>` - покажет коммит.
* `git show --pretty=fuller` - показать полную информацию о коммите.
* `git stash` - собирает незакоммиченные изменения, удаляет их из файлов и в специальном виде архивирует в git. Если нужно сменить ветку без удаления незакоммиченных изменений.
* `git stash pop` - вернуть изменения в файл. Так как git не привязывает сохранённые изменения ни к какой ветке, то можно сохранить (git stash) имненения на одной ветке, а применить (git stash pop) в другой.
* `git status` - показывает статус.
* `git update-index --chmod=+x <файл>` - сделать файл в индекс исполнимым.

[К содержанию](#содержание)
