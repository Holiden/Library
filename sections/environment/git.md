# Git

## Содержание

1. [Конфигурация](#конфигурация)
2. [.gitattributes](#gitattributes)
3. [Основы Git](#основы-git)
4. [Коммит. Автор и коммитер](#коммит-автор-и-коммитер)
5. [Ветки](#ветки)
6. [Создание новой ветки из последних коммитов, передвижение веток](#создание-новой-ветки-из-последних-коммитов,-передвижение-веток)
7. [Просмотр истории и старых версий](#просмотр-истории-и-старых-версий)
8. [Слияние перемоткой](#слияние-перемоткой)
9. [Удаление веток](#удаление-веток)
10. [Полный список команд](#полный-список-команд)

[К разделам Окружения](https://github.com/Holiden/Library/blob/master/sections/environment/README.md)

[На главную](https://github.com/Holiden/Library/blob/master/README.md)

## Конфигурация

Настройки хранятся и задаются флагами (git читает настройки сначала local, затем global, затем system):

1. `--local` — настройки на уровне проекта (default). Файл располагается: `<project>/.git/config`.
2. `--global` — настройки на уровне пользователя. **Рекомендуется** все настройки задавать с этим флагом. Файл располагается: Unix: `~/.gitconfig`, Windows: `C:\Users\<USERNAME>\.gitconfig`.
3. `--system` — настройки на уровне системы. Файл располагается: Unix: `/etc/gitconfig`, Windows: `C:\Program Files\Git\etc\gitconfig` и `C:\ProgramData\Git\config`.

- `git config user.name <имя>` — задать имя пользователя.
- `git config user.email <email>` — задать email пользователя.
- `git config --list` — посмотреть параметры конфигурации.
- `git config --list --global` — посмотреть глобальные параметры конфигурации.
- `git config --unset <параметр>` — удалить параметр из конфига.
- `git config --remove-section <секция>` — удалить всю секцию настроек из конфига.
- `git config core.editor '<путь к редактору>' -w` — настроить редактор по умолчанию. `-w` — ожидать закрытие редактора.
- `git config core.autocrlf <значение>` — настройка автоматического переноса строк. **Рекомендуется** задавать в `.gitattributes`. Значения:
  - `.true` — при записи в git строки с CRLF преобразуются в LF. При чтении с git строки с CRLF преобразуются в LF. Используется для кроссплатформенности.
  - `.input` — при записи в git строки с CRLF преобразуются в LF. При чтении с git ничего не преобразуется. Используется для Windows, если основа на Unix.
  - `.false` — при записи в git строки с CRLF не преобразуются. При чтении с git строки с CRLF не преобразуются. Используется если у всех одна ОС — Windows или Unix.
- `git config core.excludeFile <файл>` — игнорировать файл. **Рекомендуется** задавать в `.gitignore`.
- `git config alias.<алиас> <команда>` — задать сокращённую команду.

[К содержанию](#содержание)

## Окончание строк и.gitattributes

Гит имеет дело с двумя системами для работы с концами строк в репозиториях. Корень проблемы в том, что популярные операционные системы по-разному обозначают конец строки: Unix, Linux и Mac OS X используют LF, а Windows CRLF. В этой статье мы не будем брать во внимание, что в предыдущих версиях Mac OS X использовался CR.

Основное решение, которое принял Гит для этой проблемы — указать, что лучший способ хранить окончания строк в репозитории для текстовых файлов — использование LF. Это правило ни к чему вас не принуждает, но большинство разработчиков, использующих Гит и Гитхаб, приняли его как соглашение и мы тоже рекомендуем так настроить ваш конфиг.

core.eol — первый параметр, о котором нужно знать.

Почти всегда, кроме самых редких случаев, нам не стоит менять дефолтное значение этого параметра. Хотя сам по себе core.eol мало что делает, нам нужно знать его значение каждый раз, когда мы хотим, чтобы Гит изменил окончания строк. Так как этот параметр будет использоваться во всём, о чём пойдёт речь дальше, хорошо бы знать о его существовании и о том, что его значение, вероятно, менять не придётся.

core.eol = native — значение по умолчанию. При записи файла в рабочую папку, Гит изменит окончания строк на соответствующие вашей платформе по умолчанию. Для Windows это будет CRLF, для Unix, Linux и Mac OS X — LF;
core.eol = crlf— если установлено такое значение, Гит всегда будет использовать для обозначения конца строки CRLF при записи файла в вашу рабочую директорию;
core.eol = lf — это значение скажет Гиту всегда использовать LF для обозначения конца строки при записи файла в вашу рабочую папку.
Чтобы узнать, какое значение core.eol установлено в вашей системе, нужно запустить в консоли команду git config --global core.eol. Если команда ничего не вернёт, значит, в вашей системе используется значение по умолчанию, native.

у Гита есть настройка конфигураций core.autocrlf, которая специально создана для того, чтобы все окончания строк в текстовом файле преобразовывались в LF при записи в объектную базу данных репозитория. Вот список разных настроек для core.autocrlf и их значений:

core.autocrlf = false — это значение по умолчанию, которое большинству людей следует сменить. Результатом использования этого значения станет то, что Гит не будет связываться с окончаниями строк в ваших файлах. Там могут быть разные окончаниями строк: LF, CRLF, CR или микс из всех них, но Гиту это будет безразлично. Такое значение может привести к тому, что диффы станут менее читаемыми и появятся сложности при слиянии веток. У большинства пользователей Unix/Linux установлено именно это значение, потому что у них нет проблем с CRLF и им не нужно, чтобы Гит делал дополнительную работу каждый раз при записи файлов в базу данных или в рабочую папку.
core.autocrlf = true — значит, что Гит обработает все текстовые файлы и убедится, что все CRLF заменены на LF перед записью в базу данных. При обратном процессе он преобразует все LF в CRLF. Такая установка гарантирует, что ваш репозиторий можно будет использовать на других платформах, сохраняя CRLF в вашем рабочей папке. Поэтому параметр true для core.autocrlf рекомендован для Windows.
core.autocrlf = input — значит, что Гит обработает все текстовые файлы и убедится, что все CRLF изменены на LF при записи файлов в базу данных. Однако обратной замены не произойдёт. При записи файлов в рабочую папку из базы данных, для обозначения конца строки останутся LF. Этот параметр обычно используется в Unix / Linux / OS X для предотвращения записи CRLF в репозиторий. Идея заключается в том, что если вы вставили код из браузера и случайно записали CRLF в один из ваших файлов, Гит удостоверится, что произойдёт замена на LF при записи в базу данных.
Чтобы увидеть, какое значение для core.autocrlf установлено в вашей системе, нужно запустить в командной строке git config --global core.autocrlf. Если команда ничего не вернёт, то вы используете значение по умолчанию, false.

Параметр core.safecrlf был создан на тот случай, если Гит ошибётся и изменит окончания строк там, где лучше было бы оставить их в покое.

core.safecrlf = true — перед записью в базу данных при подготовке к замене CRLF на LF, Гит убедится, что сможет успешно прервать операцию. Он проверит, что можно откатить изменения (из LF в CRLF), а если нет, то отменит операцию.
core.safecrlf = warn — сделает то же, что и предыдущий параметр, но вместо того, чтобы прервать операцию, Гит просто предупредит вас о том, что может случиться что-то нехорошее.
Наконец, вы можете создать в корне своего репозитория файл.gitattributes и указать в нём настройки для конкретных файлов. Это позволит вам управлять такими настройками, как autocrlf для каждого типа файлов.

Например, для того, чтобы Гит заменил CRLF на LF во всех текстовых файлах, можно написать в.gitattributes такую строку:

\*.txt crlf.

Или можно сделать, чтобы Гит никогда не заменял CRLF на LF в текстовых файлах с помощью такой строки:

\*.txt -crlf

Чтобы Гит заменял CRLF на LF в текстовых файлах только при записи в базу данных, но возвращал LF при записи в рабочий каталог, нужно написать:

\*.txt crlf=input

Для того, чтобы точно сказать git какие файлы являются текстовыми, а какие не являются, используется файл `.gitattibutes`.

Он указывает к каким файлам применены настройки.

| Шаблон  | Атрибут |
| ------- | ------- |
| \* text | = auto  |
| \*.html | text    |

У атрибута может быть 4 варианта:

1. `__` — отсутствие;
2. `text` — явное задание. Означает, что такие файлы всегда текстовые. Для таких файлов включается нормализация при записи в git CRLF → LF.
3. `text = auto` — указано со значением. Означает, что git сам должен определить текстовый это файл или бинарный. По умолчанию текстовость файлов определяется по содержимому, и если файл текстовый, то при его записи в git включается нормализация CRLF → LF.
4. `-text` — снято. Снятый атрибут это не тоже самое, что не указанный. Означает, что файл бинарный (его не трогать). Отключает нормализацию текста. Обычно ставят `binary`. Это псевдоним `-text` (его не трогать) `-merge -diff` (отключают текстовое слияние и сравнение для таких файлов).

`text` определяет, что делать с файлом при записи в git. Определяет нужно ли преобразовывать переносы строк.

`text eol=crlf` определяет, что делать с переносами строк при чтении файла с git в рабочую директорию. Значение crlf делает переносы строк Windows. Атрибут `eol` автоматически подразумевает текстовые файлы. Его можно писать без `text`.

`text eol=lf` определяет, что при чтении файла с git переносы строк менять не надо. Но если файлы в git crlf, то преобразования в lf не будет.

[К содержанию](#содержание)

## Основы Git

- `git init` — создаёт пустой репозиторий.
- `git status` — показывает статус.
- `git add <файл>` — добавить файл в индекс.
- `git commit` — открыть редактор по умолчанию чтобы написать коммит.

Каждому коммиту присваивается хеш. Все операции с файлами этого коммита проводятся через этот хеш.

Файл с игнор-шаблоном только для текущего пользователя проекта находится `<project>/.git/info/exclude`. Этот файл не передаётся через git.

### Права на файлы

После добавления файла в репозиторий перед именем файла указывается число, например 100644.  
100 — означает тип файла.  
644 — означает права на этот файл.  
В зависимости от операционной системы права могут быть разными (запись, чтение, выполнение). Git проверяет файлы только на исполнение. Если файл исполнимый, то значение будет 755, если не исполнимый — 644.

- `chmod +x <файл>` — сделать файл исполнимым.
- `chmod -x <файл>` — сделать файл не выполнимым.

Для git изменение права на выполнение существенно наравне с изменением в содержимом файла.

Файловая система Windows обычно не поддерживает отдельное право на выполнение файла. В отличии от Unix систем, в Windows, обычно, оно объединено с правом на чтение. Под Unix эти права различны. Git при создании репозитория проверяет, если файловая система не поддерживает отдельное право на выполнение, то ставит в настройках `git config core.fileMode false`. Она говорит git, что на права файловой системы вообще не смотреть. Файлы сохранённые в Windows всегда будут 644.

Чтобы создаваемый файл в Windows был исполнимым в Unix:

- `git update-index --chmod=+x <файл>` — сделать файл в индекс исполнимым.
- `git add --chmode=+x <файл>` — сделать файл в рабочей директории исполнимым.

[К содержанию](#содержание)

## Коммит. Автор и коммитер

- `git show` — показать текущий коммит.
- `git show <идентификатор, минимум 4 символа>` — покажет коммит.
- `git show --pretty=fuller` — показать полную информацию о коммите.
- `git commit --author='<имя автора>' --date='<дата>'` — установить имя автора и его дату.

Коммит может быть небольшое, но целостное и осмысленное изменение в проект.

Git не работает с пустыми директориями. Он их не видит. Обычно, чтобы этого избежать создают пустой файл с именем `.gitkeep`.

- `git add .` — добавить к индексу все текущие изменения текущей директории.
- `git add -A` — добавить к индексу все ткущие изменения, начиная с корня проекта.
- `git add -p <файл>` — добавить файл в индекс с возможностью выбора частей изменений.
- `git add --force (или -f)` — добавить файл в индекс, даже если он игнорируется.
- `git commit <файл>` — добавить отдельный файл сразу в индекс и в репозиторий. Файлы, которые git не отслеживает будут проигнорированы.
- `git commit -m '<сообщение>'` — позволяет указать сообщение прямо в командной строке без вызова редактора. Одно слово можно указывать без кавычек.
- `git commit --all (или -a)` — добавить файл в репозиторий игнорируя индекс стадию, но всё равно добавить в индекс. Эта команда игнорирует файлы, которые не отслеживаются git.
- `git mv <файл1> <файл2>` — переименовать файл1 в файл2 и добавить информацию об этом в индекс.
- `git reset HEAD <файл>` — удалить файл из индекса.
- `git rm <файл>` — удаление файла. Можно указывать несколько, Удаляет из рабочей директории и из индекса (псевдоним `rm` + `git add`).
- `git rm -f <имя>` — удалить файл игнорируя предупреждения. Удалить файл с изменениями, которые не были сохранены в репозитории. Все несохранённые изменения будут потеряны.
- `git rm -r <директория>` — удаление директории.
- `git rm --cached <файл>` — удаление файла из индекса, но сохранение в рабочей директории. Операция производится только с индексом, вместо рабочей директории.

[К содержанию](#содержание)

## Ветки

**Ветки** — это изолированный поток разработки, в котором можно делать коммиты так, что их не будет видно из других веток.

- `git branch` — просмотр веток.
- `git branch -v` — просмотр веток и информации о коммите на который они указывают.
- `git checkout <имя ветки>` — переключиться на ветку.
- `git branch <имя ветки>` — создать новую ветку.
- `git checkout -b <имя ветки>` — создать и переключиться на ветку (`git branch` + `git checkout`).

### Checkout с незакоммиченными изменениями

Если выполненные изменения не закоммичены, то сменить ветку не удастся. Если файл между ветками различается или в одной ветке файл есть, а в другой он был удалён, тогда будет ошибка, а если файл одинаковый, то незакоммиченные изменения сохраняются при смене ветки.

- `git checkout --force (или -f)` — сменить ветку игнорируя предупреждения.
- `git checkout -f HEAD` — перезаписать файлы той же ветки с последнего коммита. Если просто нужно удалить сделанные изменения. Можно даже не указывать HEAD, потому что если ветка не указана, HEAD используется по умолчанию.
- `git stash` — собирает незакоммиченные изменения, удаляет их из файлов и в специальном виде архивирует в git. Если нужно сменить ветку без удаления незакоммиченных изменений.
- `git stash pop` — вернуть изменения в файл. Так как git не привязывает сохранённые изменения ни к какой ветке, то можно сохранить (`git stash`) изменения на одной ветке, а применить (`git stash pop`) в другой.

[К содержанию](#содержание)

#### Создание новой ветки из последних коммитов, передвижение веток

Если ошибочно сделаны коммиты в ветке master, а не в нужной ветке, то необходимо создать новую ветку и передвинуть ветку master на стабильный коммит.

- `git branch <имя ветки> <идентификатор коммита>` — создать ветку на определённом коммите.
- `git branch --force (или -f) <имя ветки> <идентификатор коммита>` — создать ветку на определённом коммите или переместить ветку, если она уже существует.
- `git checkout -B <имя ветки> <идентификатор коммита>` — создать ветку на определённом коммите или переместить ветку, если она уже существует, и переключиться на неё.

[К содержанию](#содержание)

#### Просмотр истории и старых версий

- `git log` — вывести историю коммитов.
- `git log --oneline` — вывести историю коммитов в компактном виде.

По умолчанию `git log` выводит историю ветки HEAD, т. е. все коммиты.

- `git log <имя ветки>` — вывести историю коммитов определённой ветки.
- `git show` — показать текущий коммит.
- `git show HEAD~` — показать предшествующий коммит.
- `git show HEAD~~ (или HEAD~2)` — показать предшествующий коммит, который находится на 2 коммита ниже текущего.
- `git show HEAD~~~ (или HEAD~3)` — показать предшествующий коммит, который находится на 3 коммита ниже текущего.

Слово `HEAD` можно сокращать используя символ `@`. На Windows потребуются кавычки.

- `git show @~~~ (или @~3)` — показать предшествующий коммит, который находится на 3 коммита ниже текущего.
- `git show @~:index.html` — показать файл index.html из коммита родителя.
- `git show <имя ветки>:index.html` — показать файл index.html из определённой ветки.
- `git show :index.html` — показать файл index.html из индекса.
- `git show :/<слово или словосочетание в кавычках>` — показать коммит в названии которого содержится слово или словосочетание.

[К содержанию](#содержание)

#### Слияние перемоткой

- `git merge <имя ветки>` — слить указанную ветку с master.

Эта команда выполняется алгоритмом fast-forward. При нём не изменения, сделанные в ветке добавляются в master, а наоборот, указатель master перемещается так, чтобы указывать на ту же ветку которую нужно слить.

Команда `git merge` перед слиянием записывает старый идентификатор коммита в файл `.git/ORIG_HEAD`. Его можно использовать в качестве ссылки на коммит.

- `git branch -f master ORIG_HEAD` — вернуть master на коммит, который был перед выполнением команды `git merge`.

[К содержанию](#содержание)

#### Удаление веток

- `git branch -d <имя ветки>` — удалить указанную ветку.

Удалить ветку можно только после слияния её с master. Если удалить ветку не слитую, будет ошибка. Потому что коммиты удалённой ветки больше не будут участвовать не в одной из ветвей разработки. Такие коммиты называются недостижимыми. Со временем git удаляет их из своей базы.

- `git branch -D <имя ветки>` — удалить указанную не слитую ветку.

Git удаляет не ветку, а ссылку на ветку. Поэтому удалённую ветку можно восстановить.

- `git branch <имя ветки> <имя идентификатора>` — восстановить указанную не слитую ветку (имя должно быть одинаковое).

[К содержанию](#содержание)

## Полный список команд

- `git <команда> -h` — вывести опции и короткое описание команды.
- `git add <файл>` — добавить файл в индекс.
- `git add .` — добавить к индексу все текущие изменения текущей директории.
- `git add -A` — добавить к индексу все ткущие изменения, начиная с корня проекта.
- `git add -p <файл>` — добавить файл в индекс с возможностью выбора частей изменений.
- `git add --chmode=+x <файл>` — сделать файл в рабочей директории исполнимым.
- `git add --force (или -f)` — добавить файл в индекс, даже если он игнорируется.
- `git branch` — просмотр веток.
- `git branch <имя ветки>` — создать новую ветку.
- `git branch <имя ветки> <идентификатор коммита>` — создать ветку на определённом коммите.
- `git branch --force (или -f) <имя ветки> <идентификатор коммита>` — создать ветку на определённом коммите или переместить ветку, если она уже существует.
- `git branch -f master ORIG_HEAD` — вернуть master на коммит, который был перед выполнением команды `git merge`.
- `git branch -v` — просмотр веток и информации о коммите на который они указывают.
- `git check-ignore -v <файл>` — проверить игнорирование файла.
- `git checkout <имя ветки>` — переключиться на ветку.
- `git checkout <имя ветки или идентификатор коммита> <имя файла или директории>` — вытащить файл из определённого коммита и добавить его в индекс.
- `git checkout -b <имя ветки>` — создать и переключиться на ветку (`git branch` + `git checkout`).
- `git checkout -B <имя ветки> <идентификатор коммита>` — создать ветку на определённом коммите или переместить ветку, если она уже существует, и переключиться на неё (`git branch -f` + `git checkout`).
- `git checkout -f HEAD` — перезаписать файлы той же ветки с последнего коммита. Если просто нужно удалить сделанные изменения. Можно даже не указывать HEAD, потому что если ветка не указана, HEAD используется по умолчанию.
- `git checkout --force (или -f) <имя ветки>` — сменить ветку игнорируя предупреждения.
- `git checkout <имя файла>` — вернуть файл из индекса.
- `git checkout HEAD <имя файла>` — вернуть файл из репозитория.
- `git commit` — открыть редактор по умолчанию чтобы написать коммит.
- `git commit <файл>` — добавить отдельный файл сразу в индекс и в репозиторий. Файлы, которые git не отслеживает будут проигнорированы.
- `git commit -m '<сообщение>'` — позволяет указать сообщение прямо в командной строке без вызова редактора. Одно слово можно указывать без кавычек.
- `git commit --all (или -a)` — добавить файл в репозиторий игнорируя индекс стадию, но всё равно добавить в индекс. Эта команда игнорирует файлы, которые не отслеживаются git.
- `git commit --author='<имя автора>' --date='<дата>'` — установить имя автора и его дату.
- `git config alias.<алиас> <команда>` — задать сокращённую команду.
- `git config core.autocrlf <значение>` — настройка автоматического переноса строк. **Рекомендуется** задавать в.`gitattributes`. Значения:
  `.true` — при записи в git строки с CRLF преобразуются в LF. При чтении с git строки с CRLF преобразуются в LF. Используется для кроссплатформенности.
  `.input` — при записи в git строки с CRLF преобразуются в LF. При чтении с git ничего не преобразуется. Используется для Windows, если основа на Unix.
  `.false` — при записи в git строки с CRLF не преобразуются. При чтении с git строки с CRLF не преобразуются. Используется если у всех одна ОС — Windows или Unix.
- `git config core.editor '<путь к редактору>' -w` — настроить редактор по умолчанию. `-w` — ожидать закрытие редактора.
- `git config core.excludeFile <файл>` — игнорировать файл. **Рекомендуется** задавать в `.gitignore`.
- `git config core.pager 'less -RFX'` — конфигурация программы-читалки по умолчанию.
- `git config user.name <имя>` — задать имя пользователя.
- `git config user.email <email>` — задать email пользователя.
- `git config --list` — посмотреть параметры конфигурации.
- `git config --list --global` — посмотреть глобальные параметры конфигурации.
- `git config --remove-section <секция>` — удалить всю секцию настроек из конфига.
- `git config --unset <параметр>` — удалить параметр из конфига.
- `git help <команда>` — подробное описание команды.
- `git init` — создаёт пустой репозиторий.
- `git log` — вывести историю коммитов.
- `git log <имя ветки>` — вывести историю коммитов определённой ветки.
- `git log --oneline` — вывести историю коммитов в компактном виде.
- `git merge <имя ветки>` — слить указанную ветку с master.
- `git mv <файл1> <файл2>` — переименовать файл1 в файл2 и добавить информацию об этом в индекс.
- `git reset HEAD <файл>` — удалить файл из индекса.
- `git rm <файл>` — удаление файла. Можно указывать несколько, Удаляет из рабочей директории и из индекса (псевдоним `rm` + `git add`).
- `git rm -f <имя>` — удалить файл игнорируя предупреждения. Удалить файл с изменениями, которые не были сохранены в репозитории. Все несохранённые изменения будут потеряны.
- `git rm -r <директория>` — удаление директории.
- `git rm --cached <файл>` — удаление файла из индекса, но сохранение в рабочей директории. Операция производится только с индексом, вместо рабочей директории.
- `git show` — показать текущий коммит.
- `git show <идентификатор, минимум 4 символа>` — покажет коммит.
- `git show HEAD~` — показать предшествующий коммит.
- `git show HEAD~~ (или HEAD~2)` — показать предшествующий коммит, который находится на 2 коммита ниже текущего.
- `git show HEAD~~~ (или HEAD~3)` — показать предшествующий коммит, который находится на 3 коммита ниже текущего.
- `git show @~~~ (или @~3)` — показать предшествующий коммит, который находится на 3 коммита ниже текущего.
- `git show @~:index.html` — показать файл index.html из коммита родителя.
- `git show <имя ветки>:index.html` — показать файл index.html из определённой ветки.
- `git show :index.html` — показать файл index.html из индекса.
- `git show :/<слово или словосочетание в кавычках>` — показать коммит в названии которого содержится слово или словосочетание.
- `git show --pretty=fuller` — показать полную информацию о коммите.
- `git stash` — собирает незакоммиченные изменения, удаляет их из файлов и в специальном виде архивирует в git. Если нужно сменить ветку без удаления незакоммиченных изменений.
- `git stash pop` — вернуть изменения в файл. Так как git не привязывает сохранённые изменения ни к какой ветке, то можно сохранить (`git stash`) измненения на одной ветке, а применить (`git stash pop`) в другой.
- `git status` — показывает статус.
- `git update-index --chmod=+x <файл>` — сделать файл в индекс исполнимым.

[К содержанию](#содержание)

Отменить коммит, но оставить все изменения

`git reset --soft HEAD~1`
